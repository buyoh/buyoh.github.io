<div class="block">
<h4 class="shadow">解説</h4>
<div>
<!--
\( 1+1\)
	div タグでも preタグでもお好きにどうぞ もちろんMathJaxが使えます。
-->
<p>
    考察すると、次が成立することが分かります。
</p>
<ol>
    <li>最左のコマンドによってのみ、最左列にブロックを落とすことができる</li>
    <li>コマンドの順序を並び替えても結果は同じである（標準出力は並び替え前のものを出力しなければならない）</li>
</ol>

<br>
<p>
    逆シミュレートしましょう。すなわち、既にフィールドに落とされているブロックをコマンドとパックによって回収することを考えます。
</p>
<!--
<p>
   それでは、それぞれのコマンドが回収するブロックはどのように求めればよいでしょうか？
</p>
<p>
    単純な方法として、パックにブロックを出来るだけ多く詰め込む方法が考えられます。
</p>
<div>
    <img src="https://buyoh.github.io/f/yukicoder/1435/ed1.png">
</div>
<p>
    この方法では、図に示したように「割り当てるブロックが無い」状態になることがあります。<br>
    この解は制約を満たしません。
</p>
<br>

<p>
    そこで、初めに全てのパックに1ブロックずつ割り当て、その後、残っているブロックを回収することを考えます。
</p>
<p>
    しかし、この方法でも、割り当てていく順番によっては、同様に「割り当てるブロックが無い」状態になることがあります。<br>
    例えば、次の図のような場合が考えられます。
</p>
<div>
    <img src="https://buyoh.github.io/f/yukicoder/1435/ed2.png">
</div>
<br>
<p>
ここで一番上で示した考察を使います。
</p>
-->
<p>
    「最左のコマンドによってのみ、最左列にブロックを落とすことができる」ので、左側のコマンドから順に最左のブロックを割り当てます。
</p>
<p>
    つまり、コマンドの指定座標が昇順になるように並び替えて、そのコマンドの順にブロックを割り当てれば良いです。
</p>
<div>
    <img src="https://buyoh.github.io/f/yukicoder/1435/ed3.png">
</div>
<!--
コマンド群を最左のコマンドが先頭になるようにソートして、昇順にそのパックがブロックを落とすことができる範囲のブロックのうち最左のブロックを割り当てる。
-->
<p>
    ブロックを1つずつ割り当てたら、残りのブロックも同様にパックに詰めていきます。
</p>
<p>
    これで、制約を満たすようなパックを作ることは出来ます。<br>
    計算量は $O(HW + NlogN + N)$ です。
</p>
<br>
<p>
    ただし、出力する際には標準入力で与えられた順番と同じ順でパックの中身を出力する点に注意。<br>
    ソート前の順番で出力しなければなりません。<br>
</p>
<!--
<p>
    ソート前の情報を保持する方法として、「データそのものではなく、インデックスをソートする」方法があります。<br>
    c++14で記述すると次のようなプログラムになります。
</p>
<pre>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;vector>
using namespace std;

vector&lt;int> data = {6,3,1,2};   // ソートしたいデータ
vector&lt;int> datai(data.size()); // インデックス

// a番目のデータとb番目のデータのどちらが大きいか比較する関数
bool my_compare(int a,int b){
    return data[a] &lt; data[b];
}

int main(){

    // 比較前のインデックス番号をセットする
    for (int i = 0; i &lt; data.size(); i++)
        datai[i] = i;
        
    // my_compareで比較するソートを行う。
    sort(datai.begin(), datai.end(), my_compare );

    for (int i = 0;i &lt; data.size(); i++){
       cout &lt;&lt; (i+1) &lt;&lt; "番目に小さいデータは" &lt;&lt; (datai[i]+1) &lt;&lt; "番目のデータで、その値は" &lt;&lt; data[data[i]] &lt;&lt; endl;
    }
    
    return 0;
}
</pre>
<br><br>
<p>以上の解説でAcceptできると思います。</p>
<p>
    解説では一般的な(計算量が$O(NlogN)$であるような)ソートで説明しましたが、バケットソートが有利です。<br>
    この場合の計算量は$O(HW + N + (N + W) \times フィールドからブロックを取り出す計算量)$になります。
</p>
<p>
    $フィールドからブロックを取り出す計算量$は、$O(1)$です。
</p>
-->
<br><br>

<p><a href="http://yukicoder.me/submissions/132194">writerコード</a></p>

<br><br>
<p>2017/01/11追記</p>
<p>
    最小流制約付き最大流問題に帰着出来ることを<a href="http://buyoh.hateblo.jp/entry/2017/01/10/235356">確認</a>しました．頂点数$W+N+2$，辺数$W+4N$の大きさのグラフになります．<br>
</p>
<br>
<p>2017/09/18編集</p>
<p>簡略化しました</p>
</div>
</div>
